#!/usr/bin/env bash

# ppwn script - Move binary to ~/nixos/ctfs/ppwn/<name>/

# Check if an executable was provided as second argument
if [ $# -lt 1 ]; then
    echo "Usage: ppwn <executable>"
    exit 1
fi

executable="$1"

# Check if the executable exists
if [ ! -f "$executable" ]; then
    echo "Error: File '$executable' does not exist"
    exit 1
fi

# Check if the file is executable
if [ ! -x "$executable" ]; then
    echo "Warning: File '$executable' is not executable, but proceeding anyway"
fi

# Get the executable name (basename without path)
executable_name=$(basename "$executable")

# Prompt user for folder name, default to executable name
read -p "Enter folder name (default: $executable_name): " folder_name

# Use default if user didn't enter anything
if [ -z "$folder_name" ]; then
    folder_name="$executable_name"
fi

# Create the target directory
target_dir="$HOME/dev/ctfs/ppwn/$folder_name"
mkdir -p "$target_dir"

# Move the executable to the target directory
mv "$executable" "$target_dir/"

# Make it executable
chmod +x "$target_dir/$executable_name"

# Fix binary for NixOS compatibility
echo "Fixing binary for NixOS compatibility..."

# Check file type
file_type=$(file "$target_dir/$executable_name")

if echo "$file_type" | grep -q "ELF"; then
    # Handle ELF binaries
    if command -v patchelf >/dev/null 2>&1; then
        # Get current interpreter
        current_interpreter=$(patchelf --print-interpreter "$target_dir/$executable_name" 2>/dev/null)

        if [ $? -eq 0 ] && [ -n "$current_interpreter" ]; then
            # Get NixOS glibc path
            nixos_glibc=$(find /nix/store -name "ld-linux-x86-64.so.2" 2>/dev/null | head -1)
            if [ -n "$nixos_glibc" ]; then
                nixos_interpreter=$(dirname "$nixos_glibc")/ld-linux-x86-64.so.2
                patchelf --set-interpreter "$nixos_interpreter" "$target_dir/$executable_name"
                echo "✅ ELF binary interpreter fixed for NixOS"
            else
                echo "⚠️  Could not find NixOS glibc, skipping ELF interpreter fix"
            fi
        else
            echo "ℹ️  ELF binary does not need interpreter fixing"
        fi
    else
        echo "⚠️  patchelf not found, skipping ELF binary compatibility fix"
    fi
elif echo "$file_type" | grep -q "shell script"; then
    # Handle shell scripts
    if grep -q "^#!/bin/bash" "$target_dir/$executable_name"; then
        sed -i "s|#!/bin/bash|#!/run/current-system/sw/bin/bash|" "$target_dir/$executable_name"
        echo "✅ Shell script shebang fixed for NixOS"
    elif grep -q "^#!/usr/bin/env bash" "$target_dir/$executable_name"; then
        echo "✅ Shell script shebang already compatible with NixOS"
    fi
else
    echo "ℹ️  Unknown file type, skipping compatibility fixes"
fi

echo "Successfully moved '$executable' to '$target_dir/$executable_name'"

# Create flag.txt file
echo "Creating flag.txt..."
echo "FT{EXAMPLE_FLAG}" > "$target_dir/flag.txt"
echo "flag.txt created: $target_dir/flag.txt"

# Create common dependency files that CTF binaries might need
echo "Creating common dependency files..."

# Create input.txt for binaries that read from files
echo "test_input" > "$target_dir/input.txt"
echo "input.txt created: $target_dir/input.txt"

# Create data.txt for various challenges
echo "sample_data" > "$target_dir/data.txt"
echo "data.txt created: $target_dir/data.txt"

# Create payload.txt for testing inputs
echo "A" * 100 > "$target_dir/payload.txt"
echo "payload.txt created: $target_dir/payload.txt"

# Create analysis directory
analysis_dir="$target_dir/analysis"
mkdir -p "$analysis_dir"

# Run security analysis on the binary
echo "Running security analysis..."

# Run file command and save output
echo "Running file analysis..."
file "$target_dir/$executable_name" > "$analysis_dir/file_info.txt" 2>&1
echo "file output saved to: $analysis_dir/file_info.txt"

# Run checksec and save output
echo "Running checksec..."
checksec --file="$target_dir/$executable_name" > "$analysis_dir/checksec.txt" 2>&1
echo "checksec output saved to: $analysis_dir/checksec.txt"

# Run strings and save output
echo "Running strings analysis..."
strings "$target_dir/$executable_name" > "$analysis_dir/strings.txt" 2>&1
echo "strings output saved to: $analysis_dir/strings.txt"

# Run pwntools analysis
echo "Running pwntools analysis..."
python3 /home/fractal-tess/nixos/scripts/pwn_analyze.py "$target_dir/$executable_name" "$analysis_dir"
echo "pwntools analysis completed."

# Run vulnerability quick scan
echo "Running vulnerability quick scan..."
python3 /home/fractal-tess/nixos/scripts/vuln_scan.py "$target_dir/$executable_name" "$analysis_dir"
echo "vulnerability scan completed."

# Create exploit.py template
echo "Creating exploit.py template..."
cat > "$target_dir/exploit.py" << EOF
#!/usr/bin/env python3
from pwn import *

# ===== SETUP =====
binary = './$executable_name'        # Your binary here
host = '127.0.0.1'        # Remote host
port = 1337               # Remote port

context.binary = binary
context.log_level = 'info'

# ===== CONNECTION =====
if args.REMOTE:
    io = remote(host, port)
elif args.GDB:
    io = gdb.debug(binary, '''
        break main
        continue
    ''')
else:
    io = process(binary)

# ===== EXPLOIT =====

# Receive data
io.recvuntil(b'prompt: ')

# Send payload
payload = b'A' * 100
io.sendline(payload)

# Get shell
io.interactive()

# ===== RUN IT =====
# python exploit.py          → local
# python exploit.py REMOTE   → remote
# python exploit.py GDB      → debug
EOF
chmod +x "$target_dir/exploit.py"
echo "exploit.py template created: $target_dir/exploit.py"

echo "Security analysis completed."

# Change to the target directory
cd "$target_dir"

echo "Changed directory to: $target_dir"