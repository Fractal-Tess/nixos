#!/usr/bin/env bash

# ppwn script - Move binary to ~/nixos/ctfs/ppwn/<name>/ or init current directory

# Check if init mode is requested
if [ "$1" = "init" ]; then
    # Init mode - work in current directory
    if [ $# -lt 2 ]; then
        echo "Usage: ppwn init <executable>"
        exit 1
    fi

    executable="$2"
    init_mode=true
    target_dir=$(pwd)
else
    # Normal mode - create new directory
    if [ $# -lt 1 ]; then
        echo "Usage: ppwn <executable>"
        echo "Usage: ppwn init <executable>  # Initialize current directory"
        exit 1
    fi

    executable="$1"
    init_mode=false
fi

# Check if the executable exists
if [ ! -f "$executable" ]; then
    echo "Error: File '$executable' does not exist"
    exit 1
fi

# Check if the file is executable
if [ ! -x "$executable" ]; then
    echo "Warning: File '$executable' is not executable, but proceeding anyway"
fi

# Get the executable name (basename without path)
executable_name=$(basename "$executable")

# In init mode, don't move the executable, just work with it in place
if [ "$init_mode" = true ]; then
    echo "Initializing current directory for binary analysis..."
    echo "Working with executable: $executable_name"
    echo "Analysis directory: $target_dir"
else
    # Normal mode - prompt for folder name and move executable
    read -p "Enter folder name (default: $executable_name): " folder_name

    # Use default if user didn't enter anything
    if [ -z "$folder_name" ]; then
        folder_name="$executable_name"
    fi

    # Create the target directory
    target_dir="$HOME/dev/ctfs/ppwn/$folder_name"
    mkdir -p "$target_dir"

    # Move the executable to the target directory
    mv "$executable" "$target_dir/"
    echo "Moved '$executable' to '$target_dir/$executable_name'"
fi

# Make it executable
chmod +x "$target_dir/$executable_name"

# Fix binary for NixOS compatibility
echo "Fixing binary for NixOS compatibility..."

# Check file type
file_type=$(file "$target_dir/$executable_name")

if echo "$file_type" | grep -q "ELF"; then
    # Handle ELF binaries
    if command -v patchelf >/dev/null 2>&1; then
        # Get current interpreter
        current_interpreter=$(patchelf --print-interpreter "$target_dir/$executable_name" 2>/dev/null)

        if [ $? -eq 0 ] && [ -n "$current_interpreter" ]; then
            # Get NixOS glibc path
            nixos_glibc=$(find /nix/store -name "ld-linux-x86-64.so.2" 2>/dev/null | head -1)
            if [ -n "$nixos_glibc" ]; then
                nixos_interpreter=$(dirname "$nixos_glibc")/ld-linux-x86-64.so.2
                patchelf --set-interpreter "$nixos_interpreter" "$target_dir/$executable_name"
                echo "✅ ELF binary interpreter fixed for NixOS"
            else
                echo "⚠️  Could not find NixOS glibc, skipping ELF interpreter fix"
            fi
        else
            echo "ℹ️  ELF binary does not need interpreter fixing"
        fi
    else
        echo "⚠️  patchelf not found, skipping ELF binary compatibility fix"
    fi
elif echo "$file_type" | grep -q "shell script"; then
    # Handle shell scripts
    if grep -q "^#!/bin/bash" "$target_dir/$executable_name"; then
        sed -i "s|#!/bin/bash|#!/run/current-system/sw/bin/bash|" "$target_dir/$executable_name"
        echo "✅ Shell script shebang fixed for NixOS"
    elif grep -q "^#!/usr/bin/env bash" "$target_dir/$executable_name"; then
        echo "✅ Shell script shebang already compatible with NixOS"
    fi
else
    echo "ℹ️  Unknown file type, skipping compatibility fixes"
fi

if [ "$init_mode" = true ]; then
    echo "Current directory initialized for '$executable_name'"
else
    echo "Successfully moved '$executable' to '$target_dir/$executable_name'"
fi

# Create flag.txt file
echo "Creating flag.txt..."
echo "FT{EXAMPLE_FLAG}" > "$target_dir/flag.txt"
echo "flag.txt created: $target_dir/flag.txt"


# Create analysis directory
analysis_dir="$target_dir/analysis"
mkdir -p "$analysis_dir"

# Run security analysis on the binary
echo "Running security analysis..."

# Run file command and save output
echo "Running file analysis..."
file "$target_dir/$executable_name" > "$analysis_dir/file_info.txt" 2>&1
echo "file output saved to: $analysis_dir/file_info.txt"

# Run checksec and save output
echo "Running checksec..."
checksec --file="$target_dir/$executable_name" > "$analysis_dir/checksec.txt" 2>&1
echo "checksec output saved to: $analysis_dir/checksec.txt"

# Run strings and save output
echo "Running strings analysis..."
strings "$target_dir/$executable_name" > "$analysis_dir/strings.txt" 2>&1
echo "strings output saved to: $analysis_dir/strings.txt"

# Run objdump disassembly analysis
echo "Running objdump disassembly analysis..."
# Disassemble all sections
objdump -D "$target_dir/$executable_name" > "$analysis_dir/objdump_full.txt" 2>&1
echo "objdump full disassembly saved to: $analysis_dir/objdump_full.txt"

# Disassemble specific common sections
for section in .text .data .bss .rodata .got .plt; do
    echo "Disassembling section: $section"
    objdump -j "$section" -d "$target_dir/$executable_name" > "$analysis_dir/objdump_${section#.}.txt" 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "objdump $section section saved to: $analysis_dir/objdump_${section#.}.txt"
    fi
done

# Get section headers information
objdump -h "$target_dir/$executable_name" > "$analysis_dir/objdump_sections.txt" 2>&1
echo "objdump section headers saved to: $analysis_dir/objdump_sections.txt"

echo "objdump analysis completed."

# Run pwntools analysis
echo "Running pwntools analysis..."
python3 /home/fractal-tess/nixos/scripts/pwn_analyze.py "$target_dir/$executable_name" "$analysis_dir"
echo "pwntools analysis completed."

# Run vulnerability quick scan
echo "Running vulnerability quick scan..."
python3 /home/fractal-tess/nixos/scripts/vuln_scan.py "$target_dir/$executable_name" "$analysis_dir"
echo "vulnerability scan completed."

# Create exploit.py template
echo "Creating exploit.py template..."
cat > "$target_dir/exploit.py" << EOF
#!/usr/bin/env python3
from pwn import *

# ===== SETUP =====
binary = './$executable_name'        # Your binary here
host = '127.0.0.1'        # Remote host
port = 1337               # Remote port

context.binary = binary
context.log_level = 'info'

# ===== CONNECTION =====
if args.REMOTE:
    io = remote(host, port)
elif args.GDB:
    io = gdb.debug(binary, '''
        break main
        continue
    ''')
else:
    io = process(binary)

# ===== EXPLOIT =====

# Receive data
io.recvuntil(b'prompt: ')

# Send payload
payload = b'A' * 100
io.sendline(payload)

# Get shell
io.interactive()

# ===== RUN IT =====
# python exploit.py          → local
# python exploit.py REMOTE   → remote
# python exploit.py GDB      → debug
EOF
chmod +x "$target_dir/exploit.py"
echo "exploit.py template created: $target_dir/exploit.py"

echo "Security analysis completed."

# Change to the target directory (only in normal mode)
if [ "$init_mode" = false ]; then
    cd "$target_dir"
    echo "Changed directory to: $target_dir"
else
    echo "Analysis files created in current directory"
fi