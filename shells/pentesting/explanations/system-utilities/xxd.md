# XXD - Hexdump and Reverse Tool

## Overview
XXD is a command-line tool for:
- Creating hex dumps of files
- Converting hex to binary
- Viewing binary data in hexadecimal
- File data manipulation
- Binary file analysis

## Basic Usage

### Create Hex Dumps
```bash
# Create hex dump of file
xxd filename.txt

# Show specific number of bytes
xxd -l 100 filename.txt

# Show offset in decimal
xxd -d filename.txt

# Show only hex bytes (no ASCII)
xxd -p filename.txt
```

### Basic Options
```bash
# Hex dump with line numbers (default)
xxd filename.txt

# Continuous format (no line breaks)
xxd -c 0 filename.txt

# Show file with specific columns
xxd -c 16 filename.txt

# Show file in uppercase
xxd -u filename.txt
```

## Hex Dump Formats

### Standard Format
```bash
# Default hex dump format
xxd file.txt
# Output: 00000000: 4865 6c6c 6f20 576f 726c 640a            Hello World.

# Explanation:
# 00000000: offset (hexadecimal)
# 4865 6c6c 6f: hex bytes (grouped)
# 576f 726c 640a: hex bytes (grouped)
# Hello World.: ASCII representation
```

### Custom Formatting
```bash
# Custom number of columns
xxd -c 8 file.txt
# Output: 00000000: 4865 6c6c 6f20 576f  Hello Wo
#         00000008: 726c 640a           rld.

# Decimal offsets
xxd -d file.txt
# Output: 00000000: 4865 6c6c 6f20 576f 726c 640a            Hello World.
```

### Pure Hex Output
```bash
# Plain hex dump
xxd -p file.txt
# Output: 48656c6c6f20576f726c640a

# Group hex bytes
xxd -g 4 file.txt
# Output: 48656c6c 6f20576f 726c640a
```

## Reverse Operations

### Hex to Binary
```bash
# Convert hex dump back to binary
xxd -r hexdump.txt output.bin

# Convert plain hex back to binary
xxd -r -p hexplain.txt output.bin

# Convert standard hex dump
xxd -r hexdump.txt output.txt
```

### File Restoration
```bash
# Create hex dump and restore file
xxd original.txt > hexdump.txt
xxd -r hexdump.txt restored.txt

# Verify restoration
diff original.txt restored.txt
```

## Advanced Usage

### Partial Dumps
```bash
# Dump specific offset and length
xxd -s 100 -l 50 file.bin

# Dump from specific offset to end
xxd -s 1000 file.bin

# Dump first N bytes
xxd -l 256 file.bin
```

### File Analysis
```bash
# Show file header
xxd -l 64 file.bin

# Look for specific patterns
xxd file.bin | grep "4d5a"

# Show file in sections
xxd -s 0 -l 512 file.bin
xxd -s 512 -l 512 file.bin
```

### Binary File Manipulation
```bash
# View PE header
xxd -l 64 program.exe

# View ELF header
xxd -l 64 executable

# View archive headers
xxd -l 100 archive.zip
```

## Practical Examples

### File Signature Analysis
```bash
# Check file signatures
echo "Checking file signatures..."

# JPEG files should start with FF D8
xxd -l 4 image.jpg | grep -q "ffd8" && echo "Valid JPEG" || echo "Not JPEG"

# PNG files should start with 89 50 4E 47
xxd -l 8 image.png | grep -q "89504e47" && echo "Valid PNG" || echo "Not PNG"

# PDF files should start with 25 50 44 46 (%PDF)
xxd -l 4 document.pdf | grep -q "25504446" && echo "Valid PDF" || echo "Not PDF"
```

### Binary Data Examination
```bash
# Examine executable headers
echo "Executable headers:"
xxd -l 64 program.exe

# Look for embedded strings
xxd -c 16 file.bin | grep -E "(4865 6c6c 6f|574f 524c 44)"

# Find specific byte patterns
xxd file.bin | grep "deadbeef"
```

### Data Recovery
```bash
# Recover data from hex dump
# Assuming we have a hex dump file
xxd -r corrupted_hex.txt recovered.bin

# Verify recovered data
file recovered.bin
xxd -l 64 recovered.bin
```

## Scripting and Automation

### File Analysis Script
```bash
#!/bin/bash
# Analyze file signatures

analyze_file() {
    local file="$1"

    if [ ! -f "$file" ]; then
        echo "File not found: $file"
        return 1
    fi

    echo "Analyzing: $file"
    echo "First 64 bytes:"
    xxd -l 64 "$file"
    echo ""

    # Check common file types
    signature=$(xxd -l 8 "$file" | cut -d' ' -f2-9 | tr -d ' \n')

    case "$signature" in
        89504e47*)
            echo "File type: PNG"
            ;;
        ffd8ff*)
            echo "File type: JPEG"
            ;;
        25504446*)
            echo "File type: PDF"
            ;;
        7f454c46*)
            echo "File type: ELF executable"
            ;;
        4d5a*)
            echo "File type: Windows executable"
            ;;
        504b0304*)
            echo "File type: ZIP archive"
            ;;
        *)
            echo "File type: Unknown"
            ;;
    esac
}

# Analyze files
for file in "$@"; do
    analyze_file "$file"
    echo "----------------------------------------"
done
```

### Hex Data Extraction
```bash
#!/bin/bash
# Extract specific data from hex dumps

extract_data() {
    local file="$1"
    local offset="$2"
    local length="$3"

    xxd -s "$offset" -l "$length" "$file"
}

# Extract specific data
echo "Extracting header:"
extract_data file.bin 0 64

echo "Extracting footer:"
extract_data file.bin -64 64
```

### Data Conversion Script
```bash
#!/bin/bash
# Convert between binary and hex

binary_to_hex() {
    local input="$1"
    local output="${2:-${input}.hex}"

    xxd "$input" > "$output"
    echo "Hex dump saved to: $output"
}

hex_to_binary() {
    local input="$1"
    local output="${2:-${input%.hex}.bin}"

    if [[ "$input" == *.hex ]]; then
        xxd -r "$input" > "$output"
    else
        xxd -r -p "$input" > "$output"
    fi
    echo "Binary saved to: $output"
}

# Usage examples
case "$1" in
    "tohex")
        binary_to_hex "$2" "$3"
        ;;
    "tobin")
        hex_to_binary "$2" "$3"
        ;;
    *)
        echo "Usage: $0 [tohex|tobin] input [output]"
        ;;
esac
```

## Integration with Other Tools

### Combine with Grep
```bash
# Search for specific byte patterns
xxd file.bin | grep "deadbeef"

# Find ASCII strings in binary
xxd -c 1 file.bin | grep -E "2[0-9a-f][0-9a-f]"

# Find repeated patterns
xxd file.bin | grep -E "(..) \1"
```

### Combine with dd
```bash
# Extract specific blocks
dd if=file.bin bs=1 skip=100 count=64 | xxd

# Create hex dump of disk sectors
dd if=/dev/sda bs=512 skip=0 count=1 | xxd
```

### Pipe Operations
```bash
# Create hex dump from command output
ls -la | xxd

# Convert hex string to binary
echo "48656c6c6f" | xxd -r -p

# Process network data
nc -l 8080 | xxd
```

## Data Patterns and Analysis

### Common File Signatures
```bash
# File signatures in hex:
# JPEG: FF D8 FF
# PNG: 89 50 4E 47 0D 0A 1A 0A
# PDF: 25 50 44 46 (%PDF)
# ELF: 7F 45 4C 46
# ZIP: 50 4B 03 04
# GIF: 47 49 46 38

# Check for these patterns
check_signature() {
    local file="$1"
    local signature=$(xxd -l 8 "$file" | cut -d' ' -f2-9 | tr -d ' \n')

    echo "Signature: $signature"
}
```

### Network Packet Analysis
```bash
# Analyze captured packets
xxd -l 100 packet.cap

# Look for Ethernet headers
xxd packet.cap | grep -E "ffff ffff ffff|.. .. .. .. .. .."

# Find IP packets
xxd packet.cap | grep -E "4500|0800"
```

## Troubleshooting

### Common Issues
```bash
# File too large
# Use specific ranges
xxd -s 0 -l 1000 large_file.bin

# Binary data not readable
# Use appropriate encoding
xxd -p file.bin

# Hex dump format issues
# Check file format
file file.bin
```

### Performance
```bash
# Large files - use specific ranges
xxd -s 1000000 -l 1000 large_file.bin

# Avoid loading entire file into memory
xxd -c 16 file.bin
```

## Tips
- Use `-l` to limit output for large files
- Use `-p` for plain hex output (easier for scripts)
- Use `-s` to start from specific offset
- Use `-r` to convert hex dumps back to binary
- Use `-d` for decimal offsets when needed
- Use `-c` to control column width
- Combine with `grep` for pattern searching
- Use with `dd` for sector-level analysis
- Consider using `hexdump` as an alternative
- Be careful with `-r` on malformed hex dumps