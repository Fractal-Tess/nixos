# Ghidra - Software Reverse Engineering Framework

## Overview
Ghidra is a software reverse engineering (SRE) framework developed by the NSA featuring:
- Disassembly and decompilation
- Scripting capabilities
- Binary analysis tools
- Cross-platform support
- Plugin architecture
- Collaborative features

## Getting Started

### Launch Ghidra
```bash
# Launch Ghidra (if in PATH)
ghidra

# Launch from installation directory
/path/to/ghidra/ghidraRun

# Launch with specific project
ghidra /path/to/project
```

### Initial Setup
```bash
# Create new project
File > New Project > Non-Shared Project

# Import binary file
File > Import File > Select binary

# Set analysis options
Auto Analysis > Configure options > Analyze
```

## Basic Interface

### Main Windows
```bash
# Code Browser - Main analysis window
# Symbol Tree - Functions, data, and symbols
# Data Type Manager - Data structures and types
# Program Tree - Program structure overview
# Console - Script output and debugging
```

### Navigation
```bash
# Go to address
Ctrl+Shift+G (Linux) or Cmd+Shift+G (Mac)

# Go to function
Ctrl+G (Linux) or Cmd+G (Mac)

# Search
Ctrl+F (Linux) or Cmd+F (Mac)

# Navigate back/forward
Alt+Left/Right arrows
```

## Disassembly and Analysis

### Auto Analysis
```bash
# Run auto analysis
Analysis > Auto Analyze

# Configure analysis options
Analysis > Configure Auto Analysis

# Enable/disable specific analyzers:
# - Decompiler ID
# - Data References
# - Function Call Analysis
# - Strings
# - Constant Propagation
```

### Manual Analysis
```bash
# Define function
Right-click > Create Function

# Define data
Right-click > Data > [Data Type]

# Define string
Right-click > Data > String

# Clear defined items
Right-click > Clear [Function/Data/String]
```

## Decompilation

### Decompiler Usage
```bash
# Open decompiler window
Window > Decompiler

# Toggle between assembly and decompiled
Decompiler button in toolbar

# Copy decompiled code
Right-click > Copy

# Export decompiled code
File > Export Program > [Options]
```

### Improving Decompilation
```bash
# Define data types
Data Type Manager > Right-click > New > Structure

# Edit function signatures
Function > Edit Function Signature

# Set calling conventions
Function > Edit Function Properties

# Rename variables
Right-click variable > Rename
```

## Symbol and Data Analysis

### Symbol Table
```bash
# View symbol table
Window > Symbol Table

# Filter symbols
Filter box in Symbol Table window

# Rename symbols
Right-click symbol > Rename

# Create symbol
Right-click > Create Label
```

### Data Types
```bash
# Data Type Manager
Window > Data Type Manager

# Create new structure
Data Type Manager > Right-click > New > Structure

# Apply data type to memory
Right-click > Set Data Type > [Type]

# Edit structures
Double-click structure in Data Type Manager
```

## Cross References

### Finding References
```bash
# Find references to address
Right-click > References > Show References to Address

# Find references from function
Right-click > References > Show References from Address

# Find references to data
Right-click > References > Show References to
```

### Code Navigation
```bash
# Jump to referenced location
Double-click reference in listing

# Show reference graph
Tools > Show Reference Graph

# Find uses of variable
Right-click variable > Find Uses
```

## Scripting and Automation

### Python Scripting
```bash
# Open script manager
Window > Script Manager

# Create new script
Script Manager > Right-click > New > Script

# Run script
Script Manager > Right-click script > Run Script

# Example basic script:
from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor

# Get current function
function = getCurrentFunction()
print("Function name:", function.getName())

# Decompile function
decompiler = DecompInterface()
decompiled = decompiler.decompileFunction(function, ConsoleTaskMonitor())
print("Decompiled code:")
print(decompiled.getDecompiledFunction().getC())
```

### Built-in Scripts
```bash
# Run built-in scripts
Script Manager > Ghidra > [Script Name]

# Common useful scripts:
# - FindCrossReferences.java
# - FindStrings.java
# - DumpBinary.java
# - AnalyzeCalls.java
```

## Memory Maps and Sections

### Memory Management
```bash
# View memory map
Window > Memory Map

# Create memory block
Memory Map > Right-click > Add Memory Block

# Edit memory block properties
Right-click block > Edit Block

# Split memory blocks
Right-click block > Split Block
```

### Section Analysis
```bash
# View program sections
Window > Program Tree

# Edit section properties
Right-click section > Properties

# Re-analyze section
Right-click section > Re-analyze
```

## Pattern Matching and Search

### Text Search
```bash
# Search for text
Search > For Text...

# Search options:
# - Case sensitive
# - Regular expressions
# - All memory blocks

# Quick text search
Ctrl+L (Linux) or Cmd+L (Mac)
```

### Pattern Search
```bash
# Search for byte patterns
Search > For Bytes...

# Search for specific values
Search > For Values...

# Search with mask
Search > For P-Code...
```

## Export and Import

### Export Options
```bash
# Export program
File > Export Program

# Export formats:
# - Binary
# - C code
# - Intel hex
# - Motorola S-record
# - ELF

# Export decompiled code
Window > Decompiler > File > Export to C
```

### Import Functions
```bash
# Import additional files
File > Import File

# Import C header
File > Parse C Source

# Import data types
File > Parse C Source (Data Types)
```

## Analysis Techniques

### Function Analysis
```bash
# Identify function boundaries
Analysis > Auto Analyze > Functions

# Stack analysis
Analysis > Analyze Stack

# Function call analysis
Analysis > Function Call Analysis

# Variable tracking
Analysis > Data Reference Analysis
```

### Control Flow Analysis
```bash
# Show control flow graph
Right-click function > Graph > Control Flow Graph

# Show call graph
Tools > Show Call Graph

# Find basic blocks
Analysis > Analyze Basic Blocks
```

### Data Flow Analysis
```bash
# Find data references
Analysis > Data Reference Analysis

# Find constants
Analysis > Constant Propagation

# Find strings
Analysis > Strings
```

## Advanced Features

### Version Control
```bash
# Check in changes
File > Check In

# Check out previous versions
File > Version History

# Compare versions
File > Compare With > [Previous Version]
```

### Collaboration
```bash
# Create shared project
File > New Project > Shared Project

# Connect to server
File > Connect to Server

# Share analysis results
File > Save
```

## Practical Examples

### Basic Binary Analysis
```bash
1. Import binary: File > Import File
2. Run auto analysis: Analysis > Auto Analyze
3. Browse functions: Symbol Tree > Functions
4. View decompiled code: Window > Decompiler
5. Search for strings: Search > For Text
```

### Malware Analysis
```bash
1. Import suspicious binary
2. Run auto analysis
3. Look for suspicious API calls
4. Analyze network-related functions
5. Check for obfuscation techniques
6. Document findings
```

### Vulnerability Research
```bash
1. Import target binary
2. Analyze input handling functions
3. Look for dangerous functions (strcpy, sprintf)
4. Check buffer boundaries
5. Analyze control flow
6. Identify potential exploit locations
```

## Tips
- Start with auto analysis for initial insights
- Rename functions and variables for clarity
- Use data types to improve decompilation
- Document your findings with comments
- Save frequently to avoid losing work
- Use scripts to automate repetitive tasks
- Compare similar binaries to understand changes
- Use reference graphs to understand relationships
- Validate decompiled code against assembly
- Keep detailed notes on your analysis process